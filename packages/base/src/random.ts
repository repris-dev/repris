import { ArrayView } from './array.js';
import * as assert from './assert.js';
import { uuid } from './util.js';

export const randMax = 2147483647; // 2^31 - 1

/** random Integers between 0 and (2^31 - 1) inclusive over a uniform distribution */
export type Generator = () => number;

/**
 * Object that transform sequences of numbers generated by a generator into
 * sequences of numbers that follow a specific random variable distribution,
 */
export type Distribution = {
  (): number;
  rng: Generator;
};

/** A pseudo random number engine based on Math.random() */
export const mathRand: Generator = () => Math.round(Math.random() * randMax);

/**
 * @description A pseudo random number engine based on Linear congruential generator (LCG).
 * A LCG has a state that consists of a single integer.
 * Reference: S.K. Park, Communications of the ACM Oct 1988
 * @returns A function which generates random Integers between 0 and
 * (2^31 - 1) inclusive
 */
export function PRNGi32(seed = mathRand()): Generator {
  assert.gt(seed, 0);
  let prev = Math.round(seed) % randMax;

  // Newer "Minimum standard" recommended by Park, Miller
  // and Stockmeyer, 1993
  const A = 48271;

  // Schrage's algorithm
  const Q = randMax / A;
  const R = randMax % A;

  return () => {
    const lo = prev % Q | 0;
    const hi = (prev / Q) | 0;
    const test = A * lo - R * hi;

    prev = test > 0 ? test : test + randMax;
    return prev - 1;
  };
}

/**
 * Produces random integers on the interval [​0​, n), where the probability of each individual
 * integer i is defined as w_i/S, that is the weight of the ith integer divided by the sum
 * of all n weights.
 */
export function discreteDistribution(
  weights: ArrayView<number>,
  entropy: Generator = mathRand,
): Generator & { reweight: (idx: number, newWeight: number) => void } {
  const N = weights.length;
  const ws = new Float64Array(N);

  let sum = 0;
  for (let i = 0; i < N; i++) {
    const w = (ws[i] = weights[i]);
    assert.gte(w, 0);
    sum += w;
  }

  const gen = () => {
    assert.gt(sum, 0, 'The sum of weights must be positive');
    let thresh = (entropy() / randMax) * sum;

    for (let i = 0; i < N; i++) {
      if (thresh < ws[i]) {
        return i;
      }
      thresh -= ws[i];
    }

    assert.never();
  };

  gen.reweight = (i: number, w: number) => {
    assert.bounds(ws, i);
    assert.gte(w, 0);

    const delta = ws[i] - w;

    ws[i] = w;
    sum -= delta;
  };

  return gen;
}

/**
 * @returns A function which generates random 64-bit floating-point numbers between
 * @param min (inclusive) and @param max (exclusive). Note: this function provides a maximum of
 * 32-bits of randomness over the given range, not 64.
 */
export function uniform(min = 0, max = 1, generator = mathRand): Distribution {
  const range = max - min;
  const fn = () => min + range * (generator() / randMax);

  fn.rng = generator;
  return fn;
}

/**
 * @returns A function which generates random 64-bit floating-point numbers between
 * @param min (inclusive) and @param max (inclusive).
 */
export function uniformi(min = 0, max = 1, generator = mathRand): Distribution {
  min = Math.ceil(min);
  max = Math.floor(max);

  const range = max - min + 1;
  const fn = () => min + Math.floor(range * (generator() / randMax));

  fn.rng = generator;
  return fn;
}

/**
 * Marsaglia polar method for generating a pair of independent
 * standard normal random variables.
 * See: https://en.wikipedia.org/wiki/Marsaglia_polar_method
 */
export function gaussian(mean = 0, stdDev = 1, generator = mathRand): Distribution {
  const uni = uniform(-1, 1, generator);

  const fn = () => {
    let u, s;

    do {
      u = uni();
      const v = uni();
      s = u * u + v * v;
    } while (s >= 1 || s === 0);

    const mul = Math.sqrt((-2.0 * Math.log(s)) / s);
    return mean + stdDev * u * mul;
  };

  fn.rng = generator;
  return fn;
}

export function newUuid(): uuid;
export function newUuid(crypto?: Crypto): uuid;
export function newUuid(generator?: Generator): uuid;

/**
 * Generate a RFC4122-compliant UUID
 * @param generator Optional source of entropy.
 */
export function newUuid(opt?: Crypto | Generator) {
  // use global crypto
  if (opt === void 0) return globalThis.crypto.randomUUID();

  // use supplied crypto
  if (typeof (opt as Crypto).randomUUID === 'function') {
    return (opt as Crypto).randomUUID();
  }

  // pseudo-random uuid
  const generator = opt as Generator;
  // Inspired by https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid
  return (<any>[1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c: any) =>
    (c ^ (generator() % 256 & (15 >> (c / 4)))).toString(16),
  );
}
