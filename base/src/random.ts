import * as assert from './assert.js';
import { uuid } from './util.js';

export const randMax = 2147483647; // 2^31 - 1

/** random Integers between 0 and (2^31 - 1) inclusive over a uniform distribution */
export type Generator = () => number;

/**
 * Object that transform sequences of numbers generated by a generator into
 * sequences of numbers that follow a specific random variable distribution,
 */
export type Distribution = {
  (): number;
  rng: Generator;
};

/**
 * A pseudo random number engine based on Math.random()
 */
export const mathRand: Generator = () => Math.round(Math.random() * randMax);

/**
 * @description A pseudo random number engine based on Linear congruential generator (LCG).
 * A LCG has a state that consists of a single integer.
 * Reference: S.K. Park, Communications of the ACM Oct 1988
 * @returns A function which generates random Integers between 0 and
 * (2^31 - 1) inclusive
 */
export function PRNGi32(seed = mathRand()): Generator {
  assert.gt(seed, 0);
  let prev = Math.round(seed) % randMax;

  // Newer "Minimum standard" recommended by Park, Miller
  // and Stockmeyer, 1993
  const A = 48271;

  // Schrage's algorithm
  const Q = randMax / A;
  const R = randMax % A;

  return () => {
    const lo = (prev % Q) | 0;
    const hi = (prev / Q) | 0;
    const test = (A * lo) - (R * hi);

    prev = test > 0 ? test : test + randMax;
    return prev - 1;
  };
}

/**
 * @returns A function which generates random 64-bit floating-point numbers between
 * @param min (inclusive) and @param max (exclusive). Note: this function provides a maximum of
 * 32-bits of randomness over the given range, not 64.
 */
export function uniform(min = 0, max = 1, generator = mathRand): Distribution {
  const range = max - min;
  const fn = () => min + range * (generator() / randMax);

  fn.rng = generator;
  return fn;
}

/**
 * @returns A function which generates random 64-bit floating-point numbers between
 * @param min (inclusive) and @param max (inclusive).
 */
export function uniformi(min = 0, max = 1, generator = mathRand): Distribution {
  min = Math.ceil(min);
  max = Math.floor(max);

  const range = max - min + 1;
  const fn = () => min + Math.floor(range * (generator() / randMax));

  fn.rng = generator;
  return fn;
}

/**
 * Marsaglia polar method for generating a pair of independent
 * standard normal random variables.
 * See: https://en.wikipedia.org/wiki/Marsaglia_polar_method
 */
export function gaussian(mean = 0, stdDev = 1, generator = mathRand): Distribution {
  const uni = uniform(-1, 1, generator);

  const fn = () => {
    let u, v, s;
    do {
      u = uni();
      v = uni();
      s = (u * u) + (v * v);
    } while (s >= 1 || s === 0);

    const mul = Math.sqrt(-2.0 * Math.log(s) / s);
    return mean + (stdDev * u * mul);
  };

  fn.rng = generator;
  return fn;
}

/**
 * Generate a RFC4122-compliant UUID
 * @param generator Optional source of entropy.
 */
export function newUuid(generator?: Generator) {
  if (generator !== void 0) {
    // Inspired by https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid
    return (<any>[1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, (c: any) =>
      (c ^ (generator() % 256) & 15 >> c / 4).toString(16)
    );
  }

  return globalThis.crypto.randomUUID() as uuid;
}
